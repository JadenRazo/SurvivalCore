--- /dev/null
+++ b/net/survivalcore/monitoring/PerformanceMonitor.java
@@ -1,0 +_,354 @@
+package net.survivalcore.monitoring;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.logging.Logger;
+import net.survivalcore.config.SurvivalCoreConfig;
+
+/**
+ * Performance monitoring system for SurvivalCore.
+ *
+ * Tracks per-tick timing breakdowns:
+ * - Entity processing time
+ * - Block tick time
+ * - Chunk operations
+ * - Pathfinding time
+ * - Entity tracking time
+ * - Mob spawning time
+ *
+ * Also tracks async thread pool utilization.
+ */
+public final class PerformanceMonitor {
+
+    private static final Logger LOGGER = Logger.getLogger("SurvivalCore");
+    private static volatile PerformanceMonitor instance;
+
+    private final Map<String, TimingData> timings = new ConcurrentHashMap<>();
+    private final int reportInterval;
+    private int ticksSinceReport = 0;
+
+    // Lagspike tracking
+    private final LagSpikeData[] lagspikes = new LagSpikeData[50];
+    private int lagspikeIndex = 0;
+    private int lagspikeCount = 0;
+    private long currentTickNumber = 0;
+    private static final int MAX_LAGSPIKES = 50;
+    private static final long LAGSPIKE_THRESHOLD_MS = 100; // configurable in future
+
+    // Pre-defined timing categories
+    public static final String ENTITIES = "entities";
+    public static final String BLOCKS = "blocks";
+    public static final String CHUNKS = "chunks";
+    public static final String PATHFINDING = "pathfinding";
+    public static final String ENTITY_TRACKING = "entity-tracking";
+    public static final String MOB_SPAWNING = "mob-spawning";
+    public static final String REDSTONE = "redstone";
+    public static final String TICK_TOTAL = "tick-total";
+
+    // Performance optimization categories
+    public static final String DAB_SKIPPED = "dab-skipped";
+    public static final String BUDGET_DEFERRED = "budget-deferred";
+    public static final String MERGES_THROTTLED = "merges-throttled";
+    public static final String TNT_BATCHED = "tnt-batched";
+    public static final String OBSERVERS_DEBOUNCED = "observers-debounced";
+    public static final String FARM_HOTSPOTS = "farm-hotspots";
+    public static final String REDSTONE_THROTTLED = "redstone-throttled";
+    public static final String EXPLOITS_BLOCKED = "exploits-blocked";
+    public static final String ENTITIES_CLEANED = "entities-cleaned";
+
+    // Simple incrementing counters (not timing-based)
+    private final ConcurrentHashMap<String, AtomicLong> counters = new ConcurrentHashMap<>();
+
+    private PerformanceMonitor(int reportInterval) {
+        this.reportInterval = reportInterval;
+
+        // Initialize known categories
+        timings.put(ENTITIES, new TimingData());
+        timings.put(BLOCKS, new TimingData());
+        timings.put(CHUNKS, new TimingData());
+        timings.put(PATHFINDING, new TimingData());
+        timings.put(ENTITY_TRACKING, new TimingData());
+        timings.put(MOB_SPAWNING, new TimingData());
+        timings.put(REDSTONE, new TimingData());
+        timings.put(TICK_TOTAL, new TimingData());
+
+        // Initialize counter categories
+        counters.put(DAB_SKIPPED, new AtomicLong(0));
+        counters.put(BUDGET_DEFERRED, new AtomicLong(0));
+        counters.put(MERGES_THROTTLED, new AtomicLong(0));
+        counters.put(TNT_BATCHED, new AtomicLong(0));
+        counters.put(OBSERVERS_DEBOUNCED, new AtomicLong(0));
+        counters.put(FARM_HOTSPOTS, new AtomicLong(0));
+        counters.put(REDSTONE_THROTTLED, new AtomicLong(0));
+        counters.put(EXPLOITS_BLOCKED, new AtomicLong(0));
+        counters.put(ENTITIES_CLEANED, new AtomicLong(0));
+    }
+
+    public static void init() {
+        SurvivalCoreConfig config = SurvivalCoreConfig.get();
+        if (!config.monitoringEnabled) {
+            LOGGER.info("Performance monitoring is disabled");
+            return;
+        }
+
+        instance = new PerformanceMonitor(config.monitoringReportInterval);
+        LOGGER.info("Performance monitoring initialized (report interval: "
+            + config.monitoringReportInterval + " ticks)");
+    }
+
+    public static PerformanceMonitor get() {
+        return instance;
+    }
+
+    public static boolean isEnabled() {
+        return instance != null;
+    }
+
+    /**
+     * Record a timing measurement for the given category.
+     *
+     * @param category the timing category
+     * @param nanos    elapsed nanoseconds
+     */
+    public void record(String category, long nanos) {
+        TimingData data = timings.get(category);
+        if (data != null) {
+            data.record(nanos);
+        }
+    }
+
+    /**
+     * Start a timing measurement. Returns the start time in nanos.
+     */
+    public static long startTiming() {
+        return System.nanoTime();
+    }
+
+    /**
+     * End a timing measurement and record it.
+     */
+    public void endTiming(String category, long startNanos) {
+        record(category, System.nanoTime() - startNanos);
+    }
+
+    /**
+     * Called once per server tick to check if we should generate a report.
+     */
+    public void tick() {
+        currentTickNumber++;
+
+        // Check for lagspike on this tick
+        TimingSnapshot tickTotal = getSnapshot(TICK_TOTAL);
+        if (tickTotal.count > 0 && tickTotal.maxMs() >= LAGSPIKE_THRESHOLD_MS) {
+            recordLagspike(tickTotal.maxNanos);
+        }
+
+        if (reportInterval <= 0) return;
+
+        ticksSinceReport++;
+        if (ticksSinceReport >= reportInterval) {
+            ticksSinceReport = 0;
+            generateReport();
+        }
+    }
+
+    /**
+     * Record a lagspike with probable cause detection.
+     */
+    private void recordLagspike(long durationNanos) {
+        double durationMs = durationNanos / 1_000_000.0;
+        String cause = detectLagspikeCause();
+
+        LagSpikeData spike = new LagSpikeData(currentTickNumber, durationMs, cause);
+        lagspikes[lagspikeIndex] = spike;
+        lagspikeIndex = (lagspikeIndex + 1) % MAX_LAGSPIKES;
+        if (lagspikeCount < MAX_LAGSPIKES) {
+            lagspikeCount++;
+        }
+    }
+
+    /**
+     * Detect the probable cause of a lagspike based on timing breakdown.
+     */
+    private String detectLagspikeCause() {
+        TimingSnapshot entities = getSnapshot(ENTITIES);
+        TimingSnapshot chunks = getSnapshot(CHUNKS);
+        TimingSnapshot redstone = getSnapshot(REDSTONE);
+        TimingSnapshot mobSpawning = getSnapshot(MOB_SPAWNING);
+        TimingSnapshot tickTotal = getSnapshot(TICK_TOTAL);
+
+        if (tickTotal.totalMs() == 0) return "Unknown";
+
+        double entitiesPercent = (entities.totalMs() / tickTotal.totalMs()) * 100;
+        double chunksPercent = (chunks.totalMs() / tickTotal.totalMs()) * 100;
+        double redstonePercent = (redstone.totalMs() / tickTotal.totalMs()) * 100;
+        double mobSpawningPercent = (mobSpawning.totalMs() / tickTotal.totalMs()) * 100;
+
+        if (entitiesPercent > 60) return "Entity processing";
+        if (chunksPercent > 60) return "Chunk operations";
+        if (redstonePercent > 60) return "Redstone";
+        if (mobSpawningPercent > 60) return "Mob spawning";
+        return "General/mixed";
+    }
+
+    /**
+     * Get recent lagspikes (circular buffer, may contain nulls).
+     */
+    public LagSpikeData[] getLagspikes() {
+        // Return a copy in chronological order (oldest to newest)
+        LagSpikeData[] result = new LagSpikeData[lagspikeCount];
+        if (lagspikeCount == 0) return result;
+
+        if (lagspikeCount < MAX_LAGSPIKES) {
+            // Haven't wrapped yet, just copy from start
+            System.arraycopy(lagspikes, 0, result, 0, lagspikeCount);
+        } else {
+            // Wrapped, copy in two parts to get chronological order
+            int firstPart = MAX_LAGSPIKES - lagspikeIndex;
+            System.arraycopy(lagspikes, lagspikeIndex, result, 0, firstPart);
+            System.arraycopy(lagspikes, 0, result, firstPart, lagspikeIndex);
+        }
+
+        return result;
+    }
+
+    /**
+     * Get a snapshot of timing data for a category.
+     */
+    public TimingSnapshot getSnapshot(String category) {
+        TimingData data = timings.get(category);
+        if (data == null) return TimingSnapshot.EMPTY;
+        return data.snapshot();
+    }
+
+    /**
+     * Increment a simple counter (not timing-based).
+     */
+    public void incrementCounter(String name) {
+        counters.computeIfAbsent(name, k -> new AtomicLong(0)).incrementAndGet();
+    }
+
+    /**
+     * Get and reset a counter value.
+     */
+    public long getAndResetCounter(String name) {
+        AtomicLong counter = counters.get(name);
+        if (counter == null) return 0;
+        return counter.getAndSet(0);
+    }
+
+    /**
+     * Get current counter value without resetting.
+     */
+    public long getCounter(String name) {
+        AtomicLong counter = counters.get(name);
+        return counter != null ? counter.get() : 0;
+    }
+
+    /**
+     * Generate and log a performance report.
+     */
+    public void generateReport() {
+        StringBuilder report = new StringBuilder();
+        report.append("\n=== SurvivalCore Performance Report ===\n");
+
+        report.append("\nTiming Breakdown:\n");
+        for (Map.Entry<String, TimingData> entry : timings.entrySet()) {
+            TimingSnapshot snap = entry.getValue().snapshotAndReset();
+            if (snap.count == 0) continue;
+
+            report.append(String.format("  %-20s avg: %6.2fms  max: %6.2fms  count: %d\n",
+                entry.getKey(),
+                snap.avgMs(),
+                snap.maxMs(),
+                snap.count));
+        }
+
+        report.append("\nOptimization Stats:\n");
+        long dabSkipped = getAndResetCounter(DAB_SKIPPED);
+        long budgetDeferred = getAndResetCounter(BUDGET_DEFERRED);
+        long mergesThrottled = getAndResetCounter(MERGES_THROTTLED);
+        long tntBatched = getAndResetCounter(TNT_BATCHED);
+        long observersDebounced = getAndResetCounter(OBSERVERS_DEBOUNCED);
+        long farmHotspots = getAndResetCounter(FARM_HOTSPOTS);
+        long redstoneThrottled = getAndResetCounter(REDSTONE_THROTTLED);
+        long exploitsBlocked = getAndResetCounter(EXPLOITS_BLOCKED);
+        long entitiesCleaned = getAndResetCounter(ENTITIES_CLEANED);
+
+        if (dabSkipped > 0) report.append(String.format("  DAB entity ticks skipped: %d\n", dabSkipped));
+        if (budgetDeferred > 0) report.append(String.format("  Budget deferrals: %d\n", budgetDeferred));
+        if (mergesThrottled > 0) report.append(String.format("  Item merges throttled: %d\n", mergesThrottled));
+        if (tntBatched > 0) report.append(String.format("  TNT explosions batched: %d\n", tntBatched));
+        if (observersDebounced > 0) report.append(String.format("  Observers debounced: %d\n", observersDebounced));
+        if (farmHotspots > 0) report.append(String.format("  Farm hotspots detected: %d\n", farmHotspots));
+        if (redstoneThrottled > 0) report.append(String.format("  Redstone updates throttled: %d\n", redstoneThrottled));
+        if (exploitsBlocked > 0) report.append(String.format("  Exploits blocked: %d\n", exploitsBlocked));
+        if (entitiesCleaned > 0) report.append(String.format("  Entities cleaned up: %d\n", entitiesCleaned));
+
+        report.append("=======================================");
+        LOGGER.info(report.toString());
+    }
+
+    /**
+     * Thread-safe timing accumulator for a single category.
+     */
+    public static class TimingData {
+        private final AtomicLong totalNanos = new AtomicLong(0);
+        private final AtomicLong maxNanos = new AtomicLong(0);
+        private final AtomicLong count = new AtomicLong(0);
+
+        public void record(long nanos) {
+            totalNanos.addAndGet(nanos);
+            count.incrementAndGet();
+            // Update max atomically
+            long currentMax;
+            do {
+                currentMax = maxNanos.get();
+                if (nanos <= currentMax) break;
+            } while (!maxNanos.compareAndSet(currentMax, nanos));
+        }
+
+        public TimingSnapshot snapshot() {
+            return new TimingSnapshot(
+                totalNanos.get(),
+                maxNanos.get(),
+                count.get()
+            );
+        }
+
+        public TimingSnapshot snapshotAndReset() {
+            TimingSnapshot snap = snapshot();
+            totalNanos.set(0);
+            maxNanos.set(0);
+            count.set(0);
+            return snap;
+        }
+    }
+
+    /**
+     * Immutable snapshot of timing data.
+     */
+    public record TimingSnapshot(long totalNanos, long maxNanos, long count) {
+        public static final TimingSnapshot EMPTY = new TimingSnapshot(0, 0, 0);
+
+        public double avgMs() {
+            if (count == 0) return 0.0;
+            return (totalNanos / (double) count) / 1_000_000.0;
+        }
+
+        public double maxMs() {
+            return maxNanos / 1_000_000.0;
+        }
+
+        public double totalMs() {
+            return totalNanos / 1_000_000.0;
+        }
+    }
+
+    /**
+     * Lagspike data record.
+     */
+    public record LagSpikeData(long tickNumber, double durationMs, String cause) {}
+}
