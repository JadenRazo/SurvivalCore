--- /dev/null
+++ b/net/survivalcore/admin/EntityCommands.java
@@ -1,0 +_,309 @@
+package net.survivalcore.admin;
+
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextDecoration;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+import org.bukkit.command.CommandSender;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Player;
+
+/**
+ * Entity management subcommands for /survivalcore entity.
+ *
+ * Subcommands:
+ * - list [world] [type] — List entity counts by type
+ * - count [world] — Total entity count per world
+ * - remove <type> [world] [radius] — Remove entities by type
+ * - freeze [world] — Temporarily freeze entity AI
+ */
+public final class EntityCommands {
+
+    private static boolean aisFrozen = false;
+    private static final Map<String, Integer> frozenWorlds = new HashMap<>();
+
+    /**
+     * Execute entity list subcommand.
+     * Shows entity breakdown by type for a world.
+     */
+    public static void executeList(CommandSender sender, String[] args) {
+        // args: ["entity", "list", [world], [type]]
+        String worldName = args.length > 2 ? args[2] : null;
+        String typeFilter = args.length > 3 ? args[3].toUpperCase(Locale.ENGLISH) : null;
+
+        World targetWorld = null;
+        if (worldName != null) {
+            targetWorld = Bukkit.getWorld(worldName);
+            if (targetWorld == null) {
+                sender.sendMessage(
+                    Component.text("World not found: ", NamedTextColor.RED)
+                        .append(Component.text(worldName, NamedTextColor.GOLD))
+                );
+                return;
+            }
+        }
+
+        sender.sendMessage(Component.empty());
+        sender.sendMessage(
+            Component.text("Entity Breakdown", NamedTextColor.GOLD, TextDecoration.BOLD)
+        );
+        sender.sendMessage(Component.empty());
+
+        List<World> worlds = targetWorld != null ? List.of(targetWorld) : Bukkit.getWorlds();
+
+        for (World world : worlds) {
+            Map<EntityType, Integer> counts = new HashMap<>();
+            int total = 0;
+
+            for (Entity entity : world.getEntities()) {
+                if (typeFilter != null && !entity.getType().name().equals(typeFilter)) {
+                    continue;
+                }
+                counts.merge(entity.getType(), 1, Integer::sum);
+                total++;
+            }
+
+            if (total == 0) continue;
+
+            sender.sendMessage(
+                Component.text("  ", NamedTextColor.DARK_GRAY)
+                    .append(Component.text(world.getName(), NamedTextColor.YELLOW, TextDecoration.BOLD))
+                    .append(Component.text(" (", NamedTextColor.DARK_GRAY))
+                    .append(Component.text(total, NamedTextColor.WHITE))
+                    .append(Component.text(" entities)", NamedTextColor.DARK_GRAY))
+            );
+
+            counts.entrySet().stream()
+                .sorted(Map.Entry.<EntityType, Integer>comparingByValue().reversed())
+                .limit(10)
+                .forEach(entry -> {
+                    sender.sendMessage(
+                        Component.text("    • ", NamedTextColor.DARK_GRAY)
+                            .append(Component.text(formatEntityType(entry.getKey()), NamedTextColor.GRAY))
+                            .append(Component.text(": ", NamedTextColor.DARK_GRAY))
+                            .append(Component.text(entry.getValue(), NamedTextColor.WHITE))
+                    );
+                });
+
+            sender.sendMessage(Component.empty());
+        }
+    }
+
+    /**
+     * Execute entity count subcommand.
+     * Shows total entity counts per world.
+     */
+    public static void executeCount(CommandSender sender, String[] args) {
+        // args: ["entity", "count", [world]]
+        String worldName = args.length > 2 ? args[2] : null;
+
+        World targetWorld = null;
+        if (worldName != null) {
+            targetWorld = Bukkit.getWorld(worldName);
+            if (targetWorld == null) {
+                sender.sendMessage(
+                    Component.text("World not found: ", NamedTextColor.RED)
+                        .append(Component.text(worldName, NamedTextColor.GOLD))
+                );
+                return;
+            }
+        }
+
+        sender.sendMessage(Component.empty());
+        sender.sendMessage(
+            Component.text("Entity Counts", NamedTextColor.GOLD, TextDecoration.BOLD)
+        );
+        sender.sendMessage(Component.empty());
+
+        List<World> worlds = targetWorld != null ? List.of(targetWorld) : Bukkit.getWorlds();
+        int grandTotal = 0;
+
+        for (World world : worlds) {
+            int count = world.getEntityCount();
+            grandTotal += count;
+
+            sender.sendMessage(
+                Component.text("  • ", NamedTextColor.DARK_GRAY)
+                    .append(Component.text(world.getName(), NamedTextColor.YELLOW))
+                    .append(Component.text(": ", NamedTextColor.DARK_GRAY))
+                    .append(Component.text(count, NamedTextColor.WHITE))
+            );
+        }
+
+        if (worlds.size() > 1) {
+            sender.sendMessage(Component.empty());
+            sender.sendMessage(
+                Component.text("  Total: ", NamedTextColor.DARK_GRAY)
+                    .append(Component.text(grandTotal, NamedTextColor.GREEN, TextDecoration.BOLD))
+            );
+        }
+
+        sender.sendMessage(Component.empty());
+    }
+
+    /**
+     * Execute entity remove subcommand.
+     * Removes entities of a specific type.
+     */
+    public static void executeRemove(CommandSender sender, String[] args) {
+        // args: ["entity", "remove", <type>, [world], [radius]]
+        if (args.length < 3) {
+            sender.sendMessage(
+                Component.text("Usage: ", NamedTextColor.RED)
+                    .append(Component.text("/survivalcore entity remove <type> [world] [radius]", NamedTextColor.GRAY))
+            );
+            return;
+        }
+
+        String typeName = args[2].toUpperCase(Locale.ENGLISH);
+        EntityType type;
+        try {
+            type = EntityType.valueOf(typeName);
+        } catch (IllegalArgumentException e) {
+            sender.sendMessage(
+                Component.text("Invalid entity type: ", NamedTextColor.RED)
+                    .append(Component.text(typeName, NamedTextColor.GOLD))
+            );
+            return;
+        }
+
+        String worldName = args.length > 3 ? args[3] : null;
+        double radius = -1;
+
+        if (args.length > 4) {
+            try {
+                radius = Double.parseDouble(args[4]);
+                if (radius <= 0) {
+                    sender.sendMessage(Component.text("Radius must be positive", NamedTextColor.RED));
+                    return;
+                }
+            } catch (NumberFormatException e) {
+                sender.sendMessage(
+                    Component.text("Invalid radius: ", NamedTextColor.RED)
+                        .append(Component.text(args[4], NamedTextColor.GOLD))
+                );
+                return;
+            }
+        }
+
+        World targetWorld = null;
+        if (worldName != null) {
+            targetWorld = Bukkit.getWorld(worldName);
+            if (targetWorld == null) {
+                sender.sendMessage(
+                    Component.text("World not found: ", NamedTextColor.RED)
+                        .append(Component.text(worldName, NamedTextColor.GOLD))
+                );
+                return;
+            }
+        }
+
+        Player player = sender instanceof Player p ? p : null;
+        if (radius > 0 && player == null) {
+            sender.sendMessage(Component.text("Radius filtering requires a player location", NamedTextColor.RED));
+            return;
+        }
+
+        List<World> worlds = targetWorld != null ? List.of(targetWorld) : Bukkit.getWorlds();
+        int removed = 0;
+
+        for (World world : worlds) {
+            if (player != null && radius > 0 && !world.equals(player.getWorld())) {
+                continue;
+            }
+
+            for (Entity entity : world.getEntities()) {
+                if (entity.getType() != type) continue;
+                if (entity instanceof Player) continue; // Safety check
+
+                if (player != null && radius > 0) {
+                    if (entity.getLocation().distance(player.getLocation()) > radius) {
+                        continue;
+                    }
+                }
+
+                entity.remove();
+                removed++;
+            }
+        }
+
+        sender.sendMessage(
+            Component.text("✓ ", NamedTextColor.GREEN, TextDecoration.BOLD)
+                .append(Component.text("Removed ", NamedTextColor.GREEN))
+                .append(Component.text(removed, NamedTextColor.GOLD))
+                .append(Component.text(" entities of type ", NamedTextColor.GREEN))
+                .append(Component.text(formatEntityType(type), NamedTextColor.YELLOW))
+        );
+    }
+
+    /**
+     * Execute entity freeze subcommand.
+     * Toggles entity AI freeze (placeholder for now).
+     */
+    public static void executeFreeze(CommandSender sender, String[] args) {
+        // args: ["entity", "freeze", [world]]
+        String worldName = args.length > 2 ? args[2] : null;
+
+        if (worldName != null) {
+            World world = Bukkit.getWorld(worldName);
+            if (world == null) {
+                sender.sendMessage(
+                    Component.text("World not found: ", NamedTextColor.RED)
+                        .append(Component.text(worldName, NamedTextColor.GOLD))
+                );
+                return;
+            }
+
+            boolean currentState = frozenWorlds.getOrDefault(worldName, 0) == 1;
+            frozenWorlds.put(worldName, currentState ? 0 : 1);
+
+            sender.sendMessage(
+                Component.text(currentState ? "Unfroze" : "Froze", currentState ? NamedTextColor.GREEN : NamedTextColor.YELLOW)
+                    .append(Component.text(" entity AI in world ", NamedTextColor.GRAY))
+                    .append(Component.text(worldName, NamedTextColor.GOLD))
+            );
+        } else {
+            aisFrozen = !aisFrozen;
+            sender.sendMessage(
+                Component.text(aisFrozen ? "Froze" : "Unfroze", aisFrozen ? NamedTextColor.YELLOW : NamedTextColor.GREEN)
+                    .append(Component.text(" entity AI globally", NamedTextColor.GRAY))
+            );
+        }
+
+        sender.sendMessage(
+            Component.text("Note: Freeze state is not yet implemented in entity tick logic", NamedTextColor.DARK_GRAY)
+        );
+    }
+
+    /**
+     * Tab completion for entity subcommands.
+     */
+    public static List<String> tabComplete(CommandSender sender, String[] args) {
+        if (args.length == 2) {
+            return List.of("list", "count", "remove", "freeze").stream()
+                .filter(sub -> sub.startsWith(args[1].toLowerCase(Locale.ENGLISH)))
+                .toList();
+        }
+
+        if (args.length == 3 && args[1].equalsIgnoreCase("remove")) {
+            // Entity type completion
+            return List.of("ZOMBIE", "SKELETON", "CREEPER", "SPIDER", "ITEM", "ARROW", "MINECART");
+        }
+
+        return List.of();
+    }
+
+    private static String formatEntityType(EntityType type) {
+        String name = type.name().toLowerCase(Locale.ENGLISH).replace('_', ' ');
+        return name.substring(0, 1).toUpperCase(Locale.ENGLISH) + name.substring(1);
+    }
+}
