--- /dev/null
+++ b/net/survivalcore/fixes/ExploitFixes.java
@@ -1,0 +_,150 @@
+package net.survivalcore.fixes;
+
+import java.util.logging.Logger;
+import net.survivalcore.config.SurvivalCoreConfig;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+
+/**
+ * Exploit prevention utilities.
+ * Methods are called from Minecraft class patches to prevent known exploits.
+ */
+public final class ExploitFixes {
+
+    private static final Logger LOGGER = Logger.getLogger("SurvivalCore");
+
+    // TNT dupe tracking: chunkKey -> tnt count this tick
+    private static final Long2IntOpenHashMap tntPerChunk = new Long2IntOpenHashMap();
+    private static int exploitsBlocked = 0;
+
+    private ExploitFixes() {}
+
+    // === Ender Pearl Border Bypass ===
+    /**
+     * Check if an ender pearl teleport destination is valid.
+     * Called from ThrownEnderpearl patch.
+     *
+     * @param destX destination X
+     * @param destZ destination Z
+     * @param borderCenterX world border center X
+     * @param borderCenterZ world border center Z
+     * @param borderSize world border size (diameter)
+     * @return true if teleport should proceed, false if blocked
+     */
+    public static boolean isEnderPearlTeleportValid(double destX, double destZ,
+            double borderCenterX, double borderCenterZ, double borderSize) {
+        if (!SurvivalCoreConfig.get().fixEnderPearlBorderBypass) return true;
+
+        double halfSize = borderSize / 2.0;
+        boolean withinBorder = Math.abs(destX - borderCenterX) <= halfSize
+                            && Math.abs(destZ - borderCenterZ) <= halfSize;
+        if (!withinBorder) {
+            exploitsBlocked++;
+        }
+        return withinBorder;
+    }
+
+    // === Chorus Fruit Wall Phase ===
+    /**
+     * Validate chorus fruit teleport destination.
+     * Called from ChorusFruitItem patch.
+     *
+     * @param destX, destY, destZ destination coordinates
+     * @param borderCenterX, borderCenterZ world border center
+     * @param borderSize world border diameter
+     * @param isSolidAtDest whether there's a solid block at destination
+     * @return true if teleport is valid
+     */
+    public static boolean isChorusTeleportValid(double destX, double destY, double destZ,
+            double borderCenterX, double borderCenterZ, double borderSize, boolean isSolidAtDest) {
+        if (!SurvivalCoreConfig.get().fixChorusFruitWallPhase) return true;
+
+        // Block if destination is inside solid blocks
+        if (isSolidAtDest) {
+            exploitsBlocked++;
+            return false;
+        }
+
+        // Block if outside world border
+        double halfSize = borderSize / 2.0;
+        boolean withinBorder = Math.abs(destX - borderCenterX) <= halfSize
+                            && Math.abs(destZ - borderCenterZ) <= halfSize;
+        if (!withinBorder) exploitsBlocked++;
+        return withinBorder;
+    }
+
+    // === Headless Piston ===
+    /**
+     * Validate piston state to prevent headless piston creation.
+     * Called from PistonBaseBlock patch.
+     *
+     * @param isExtended current piston extended state
+     * @param isBeingPushed whether another piston is pushing this one
+     * @return true if piston operation should proceed
+     */
+    public static boolean isPistonOperationValid(boolean isExtended, boolean isBeingPushed) {
+        if (!SurvivalCoreConfig.get().fixHeadlessPiston) return true;
+        // Prevent retracting while being pushed (creates headless state)
+        if (isExtended && isBeingPushed) {
+            exploitsBlocked++;
+            return false;
+        }
+        return true;
+    }
+
+    // === Bed Explosions ===
+    /**
+     * Whether bed explosions should occur in nether/end.
+     * @return true if explosions should happen (vanilla behavior)
+     */
+    public static boolean shouldBedExplode() {
+        return SurvivalCoreConfig.get().qolBedExplosionsEnabled;
+    }
+
+    // === Portal Trap Protection ===
+    /**
+     * Check if portal exit has adequate clearance.
+     * @param exitClearBlocks number of clear blocks at portal exit (above floor)
+     * @return true if safe, false if trap detected
+     */
+    public static boolean isPortalExitSafe(int exitClearBlocks) {
+        if (!SurvivalCoreConfig.get().fixPortalTrapProtection) return true;
+        return exitClearBlocks >= 2; // Need at least 2 blocks of clearance
+    }
+
+    // === TNT Duplication Control ===
+    /**
+     * Check if more TNT can be created in this chunk this tick.
+     * Called when TNT entities are created.
+     *
+     * @param chunkKey packed chunk coordinates (ChunkPos.asLong())
+     * @return true if TNT creation is allowed
+     */
+    public static boolean canCreateTNT(long chunkKey) {
+        int limit = SurvivalCoreConfig.get().fixTntDupeLimit;
+        if (limit <= 0) return true; // 0 = unlimited
+
+        int current = tntPerChunk.getOrDefault(chunkKey, 0);
+        if (current >= limit) {
+            exploitsBlocked++;
+            return false;
+        }
+        tntPerChunk.put(chunkKey, current + 1);
+        return true;
+    }
+
+    /**
+     * Reset per-tick TNT counts. Called at start of each tick.
+     */
+    public static void resetTickCounters() {
+        tntPerChunk.clear();
+    }
+
+    /**
+     * Get and reset exploits blocked counter for monitoring.
+     */
+    public static int getAndResetExploitsBlocked() {
+        int count = exploitsBlocked;
+        exploitsBlocked = 0;
+        return count;
+    }
+}
