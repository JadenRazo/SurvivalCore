--- /dev/null
+++ b/net/survivalcore/fixes/ExploitFixes.java
@@ -1,0 +_,211 @@
+package net.survivalcore.fixes;
+
+import java.util.logging.Logger;
+import net.survivalcore.config.SurvivalCoreConfig;
+import it.unimi.dsi.fastutil.longs.Long2IntOpenHashMap;
+
+/**
+ * Exploit prevention utilities.
+ * Methods are called from Minecraft class patches to prevent known exploits.
+ */
+public final class ExploitFixes {
+
+    private static final Logger LOGGER = Logger.getLogger("SurvivalCore");
+
+    // TNT dupe tracking: chunkKey -> tnt count this tick
+    private static final Long2IntOpenHashMap tntPerChunk = new Long2IntOpenHashMap();
+    // Gravity block dupe tracking: entityId -> chunkKey for blocks that entered portal this tick
+    private static final it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap fallingBlockPortalUse = new it.unimi.dsi.fastutil.ints.Int2LongOpenHashMap();
+    private static int exploitsBlocked = 0;
+
+    private ExploitFixes() {}
+
+    // === Ender Pearl Border Bypass ===
+    /**
+     * Check if an ender pearl teleport destination is valid.
+     * Called from ThrownEnderpearl patch.
+     *
+     * @param destX destination X
+     * @param destZ destination Z
+     * @param borderCenterX world border center X
+     * @param borderCenterZ world border center Z
+     * @param borderSize world border size (diameter)
+     * @return true if teleport should proceed, false if blocked
+     */
+    public static boolean isEnderPearlTeleportValid(double destX, double destZ,
+            double borderCenterX, double borderCenterZ, double borderSize) {
+        if (!SurvivalCoreConfig.get().fixEnderPearlBorderBypass) return true;
+
+        double halfSize = borderSize / 2.0;
+        boolean withinBorder = Math.abs(destX - borderCenterX) <= halfSize
+                            && Math.abs(destZ - borderCenterZ) <= halfSize;
+        if (!withinBorder) {
+            exploitsBlocked++;
+        }
+        return withinBorder;
+    }
+
+    // === Chorus Fruit Wall Phase ===
+    /**
+     * Validate chorus fruit teleport destination.
+     * Called from ChorusFruitItem patch.
+     *
+     * @param destX, destY, destZ destination coordinates
+     * @param borderCenterX, borderCenterZ world border center
+     * @param borderSize world border diameter
+     * @param isSolidAtDest whether there's a solid block at destination
+     * @return true if teleport is valid
+     */
+    public static boolean isChorusTeleportValid(double destX, double destY, double destZ,
+            double borderCenterX, double borderCenterZ, double borderSize, boolean isSolidAtDest) {
+        if (!SurvivalCoreConfig.get().fixChorusFruitWallPhase) return true;
+
+        // Block if destination is inside solid blocks
+        if (isSolidAtDest) {
+            exploitsBlocked++;
+            return false;
+        }
+
+        // Block if outside world border
+        double halfSize = borderSize / 2.0;
+        boolean withinBorder = Math.abs(destX - borderCenterX) <= halfSize
+                            && Math.abs(destZ - borderCenterZ) <= halfSize;
+        if (!withinBorder) exploitsBlocked++;
+        return withinBorder;
+    }
+
+    // === Headless Piston ===
+    /**
+     * Validate piston state to prevent headless piston creation.
+     * Called from PistonBaseBlock patch.
+     *
+     * @param isExtended current piston extended state
+     * @param isBeingPushed whether another piston is pushing this one
+     * @return true if piston operation should proceed
+     */
+    public static boolean isPistonOperationValid(boolean isExtended, boolean isBeingPushed) {
+        if (!SurvivalCoreConfig.get().fixHeadlessPiston) return true;
+        // Prevent retracting while being pushed (creates headless state)
+        if (isExtended && isBeingPushed) {
+            exploitsBlocked++;
+            return false;
+        }
+        return true;
+    }
+
+    // === Bed Explosions ===
+    /**
+     * Whether bed explosions should occur in nether/end.
+     * @return true if explosions should happen (vanilla behavior)
+     */
+    public static boolean shouldBedExplode() {
+        return SurvivalCoreConfig.get().qolBedExplosionsEnabled;
+    }
+
+    // === Portal Trap Protection ===
+    /**
+     * Check if portal exit is safe from traps.
+     * Checks for lava, fire, void, and suffocation hazards.
+     *
+     * @param level the server level
+     * @param exitPos the portal exit position (floor level)
+     * @return true if safe, false if trap detected
+     */
+    public static boolean isPortalExitSafe(net.minecraft.server.level.ServerLevel level, net.minecraft.core.BlockPos exitPos) {
+        if (!SurvivalCoreConfig.get().fixPortalTrapProtection) return true;
+
+        // Check void (Y below world minimum)
+        if (exitPos.getY() < level.getMinY()) {
+            exploitsBlocked++;
+            return false;
+        }
+
+        // Check for lava/fire at exit position (floor, feet, head)
+        for (int y = 0; y <= 2; y++) {
+            net.minecraft.core.BlockPos checkPos = exitPos.above(y);
+            net.minecraft.world.level.block.state.BlockState state = level.getBlockState(checkPos);
+
+            // Check for lava or fire blocks
+            if (state.is(net.minecraft.world.level.block.Blocks.LAVA) ||
+                state.is(net.minecraft.world.level.block.Blocks.FIRE) ||
+                state.is(net.minecraft.world.level.block.Blocks.SOUL_FIRE)) {
+                exploitsBlocked++;
+                return false;
+            }
+        }
+
+        // Check for suffocation (solid blocks at feet/head level)
+        net.minecraft.world.level.block.state.BlockState feetState = level.getBlockState(exitPos.above(1));
+        net.minecraft.world.level.block.state.BlockState headState = level.getBlockState(exitPos.above(2));
+
+        if (!feetState.isAir() && feetState.isSolid() || !headState.isAir() && headState.isSolid()) {
+            exploitsBlocked++;
+            return false;
+        }
+
+        return true; // Exit is safe
+    }
+
+    // === Gravity Block Duplication Control ===
+    /**
+     * Check if a falling block (sand, gravel, concrete powder) can enter a portal.
+     * Prevents duplication exploits via nether portals.
+     *
+     * @param entityId the falling block entity ID
+     * @param portalChunkKey the chunk key where the portal is located
+     * @return true if the block can enter the portal
+     */
+    public static boolean canFallingBlockEnterPortal(int entityId, long portalChunkKey) {
+        if (!SurvivalCoreConfig.get().fixGravityBlockDuplication) return true;
+
+        // Check if this entity already used a portal this tick
+        if (fallingBlockPortalUse.containsKey(entityId)) {
+            long previousChunk = fallingBlockPortalUse.get(entityId);
+            // If trying to use same or different portal in same tick, block it
+            exploitsBlocked++;
+            return false;
+        }
+
+        // Track this portal use
+        fallingBlockPortalUse.put(entityId, portalChunkKey);
+        return true;
+    }
+
+    // === TNT Duplication Control ===
+    /**
+     * Check if more TNT can be created in this chunk this tick.
+     * Called when TNT entities are created.
+     *
+     * @param chunkKey packed chunk coordinates (ChunkPos.asLong())
+     * @return true if TNT creation is allowed
+     */
+    public static boolean canCreateTNT(long chunkKey) {
+        int limit = SurvivalCoreConfig.get().fixTntDupeLimit;
+        if (limit <= 0) return true; // 0 = unlimited
+
+        int current = tntPerChunk.getOrDefault(chunkKey, 0);
+        if (current >= limit) {
+            exploitsBlocked++;
+            return false;
+        }
+        tntPerChunk.put(chunkKey, current + 1);
+        return true;
+    }
+
+    /**
+     * Reset per-tick counters. Called at start of each tick.
+     */
+    public static void resetTickCounters() {
+        tntPerChunk.clear();
+        fallingBlockPortalUse.clear();
+    }
+
+    /**
+     * Get and reset exploits blocked counter for monitoring.
+     */
+    public static int getAndResetExploitsBlocked() {
+        int count = exploitsBlocked;
+        exploitsBlocked = 0;
+        return count;
+    }
+}
