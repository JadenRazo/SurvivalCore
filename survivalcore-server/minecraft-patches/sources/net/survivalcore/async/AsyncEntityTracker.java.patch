--- /dev/null
+++ b/net/survivalcore/async/AsyncEntityTracker.java
@@ -1,0 +_,190 @@
+package net.survivalcore.async;
+
+import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.LinkedBlockingQueue;
+import java.util.concurrent.ThreadFactory;
+import java.util.concurrent.ThreadPoolExecutor;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import net.survivalcore.config.SurvivalCoreConfig;
+
+/**
+ * Manages the async entity tracking thread pool.
+ *
+ * Entity position/velocity/metadata broadcasts are moved off the main tick thread
+ * to dedicated worker threads. This significantly reduces main thread load when
+ * many entities are present.
+ *
+ * NPC-type entities (from Citizens, FancyNpcs, etc.) can optionally remain on
+ * the main thread via compat-mode to prevent visibility glitches.
+ */
+public final class AsyncEntityTracker {
+
+    private static final Logger LOGGER = Logger.getLogger("SurvivalCore");
+    private static volatile AsyncEntityTracker instance;
+    private static final int CACHE_HARD_LIMIT = 5000;
+    private final ExecutorService executor;
+    private final boolean compatMode;
+    private final ConcurrentHashMap<Integer, Boolean> syncTrackingCache = new ConcurrentHashMap<>();
+    private long lastCacheCleanup = 0;
+
+    private AsyncEntityTracker(int threads, boolean compatMode) {
+        this.compatMode = compatMode;
+
+        ThreadFactory factory = new ThreadFactory() {
+            private final AtomicInteger count = new AtomicInteger(0);
+
+            @Override
+            public Thread newThread(Runnable r) {
+                Thread t = new Thread(r, "SurvivalCore-EntityTracker-" + count.getAndIncrement());
+                t.setDaemon(true);
+                t.setPriority(Thread.NORM_PRIORITY - 1);
+                return t;
+            }
+        };
+
+        this.executor = new ThreadPoolExecutor(
+            threads, threads,
+            60L, TimeUnit.SECONDS,
+            new LinkedBlockingQueue<>(4096),
+            factory,
+            new ThreadPoolExecutor.CallerRunsPolicy()
+        );
+
+        LOGGER.info("Async entity tracker initialized with " + threads + " threads"
+            + (compatMode ? " (compat-mode enabled)" : ""));
+    }
+
+    public static void init() {
+        SurvivalCoreConfig config = SurvivalCoreConfig.get();
+        if (!config.asyncEntityTrackerEnabled) {
+            LOGGER.info("Async entity tracker is disabled");
+            return;
+        }
+
+        int threads = config.resolveEntityTrackerThreads();
+        instance = new AsyncEntityTracker(threads, config.asyncEntityTrackerCompatMode);
+    }
+
+    public static AsyncEntityTracker get() {
+        return instance;
+    }
+
+    public static boolean isEnabled() {
+        return instance != null;
+    }
+
+    /**
+     * Submit an entity tracking update to run asynchronously.
+     * Falls back to synchronous execution if the queue is full (CallerRunsPolicy).
+     */
+    public void submit(Runnable task) {
+        executor.execute(task);
+    }
+
+    /**
+     * Whether NPC entities should be tracked synchronously for compatibility.
+     */
+    public boolean isCompatMode() {
+        return compatMode;
+    }
+
+    /**
+     * Mark an entity for sync tracking from the main thread.
+     * Should be called when NPC entities are spawned/created.
+     *
+     * @param entityId entity network ID
+     */
+    public void markForSyncTracking(int entityId) {
+        if (compatMode) {
+            syncTrackingCache.put(entityId, Boolean.TRUE);
+        }
+    }
+
+    /**
+     * Remove an entity from sync tracking when it's removed.
+     *
+     * @param entityId entity network ID
+     */
+    public void unmarkSyncTracking(int entityId) {
+        if (compatMode) {
+            syncTrackingCache.remove(entityId);
+        }
+    }
+
+    /**
+     * Check if an entity requires sync tracking based on cached data or class name.
+     * Thread-safe: uses concurrent cache and falls back to improved class name matching.
+     *
+     * @param entityId        entity network ID
+     * @param entityClassName simple class name of entity
+     * @return true if entity should be tracked synchronously
+     */
+    public boolean requiresSyncTracking(int entityId, String entityClassName) {
+        if (!compatMode) return false;
+
+        // Check cache first (main thread pre-tagged NPCs)
+        Boolean cached = syncTrackingCache.get(entityId);
+        if (cached != null) return cached;
+
+        // Improved class name matching - more specific patterns
+        // Only match known NPC plugin patterns, not just "NPC" substring
+        boolean isNpc = entityClassName.equals("CraftNPC")
+            || entityClassName.equals("CitizensNPC")
+            || entityClassName.equals("FancyNpc")
+            || entityClassName.equals("ZNpc")
+            || entityClassName.equals("NPCEntity")
+            || (entityClassName.startsWith("NPC") && entityClassName.length() < 20); // Avoid false positives
+
+        // Cache the result to avoid repeated checks
+        if (isNpc) {
+            syncTrackingCache.put(entityId, Boolean.TRUE);
+        }
+
+        return isNpc;
+    }
+
+    /**
+     * Clean up the sync tracking cache periodically to prevent memory leaks.
+     * Should be called from main thread every ~5 minutes.
+     *
+     * @param currentTick current server tick
+     */
+    public void cleanupCache(long currentTick) {
+        if (!compatMode) return;
+
+        // Cleanup every 6000 ticks (5 minutes)
+        if (currentTick - lastCacheCleanup > 6000) {
+            int cacheSize = syncTrackingCache.size();
+
+            // Safety valve: force-clear if cache exceeds hard limit
+            if (cacheSize > CACHE_HARD_LIMIT) {
+                LOGGER.warning("AsyncEntityTracker cache exceeded " + CACHE_HARD_LIMIT
+                    + " entries (" + cacheSize + "), force-clearing to prevent memory leak");
+                syncTrackingCache.clear();
+            } else if (cacheSize > 1000) {
+                LOGGER.warning("AsyncEntityTracker cache is large (" + cacheSize
+                    + " entries). Consider calling unmarkSyncTracking on entity removal.");
+            }
+            lastCacheCleanup = currentTick;
+        }
+    }
+
+    public void shutdown() {
+        if (executor != null) {
+            executor.shutdown();
+            try {
+                if (!executor.awaitTermination(5, TimeUnit.SECONDS)) {
+                    executor.shutdownNow();
+                }
+            } catch (InterruptedException e) {
+                executor.shutdownNow();
+                Thread.currentThread().interrupt();
+            }
+        }
+    }
+}
