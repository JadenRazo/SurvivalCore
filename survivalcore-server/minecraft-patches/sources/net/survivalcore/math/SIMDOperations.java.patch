--- /dev/null
+++ b/net/survivalcore/math/SIMDOperations.java
@@ -1,0 +_,221 @@
+package net.survivalcore.math;
+
+import jdk.incubator.vector.DoubleVector;
+import jdk.incubator.vector.FloatVector;
+import jdk.incubator.vector.VectorSpecies;
+import java.util.logging.Logger;
+
+/**
+ * SIMD-accelerated operations using Java 21 Vector API.
+ *
+ * Operations that benefit from data-parallel execution:
+ * - Map rendering: 8-wide color distance calculations
+ * - Entity distance: Batch distance checks for multiple entities
+ * - Chunk operations: Batch block state comparisons
+ *
+ * Automatically detects hardware SIMD support at runtime.
+ * Falls back to scalar operations if Vector API is unavailable.
+ */
+public final class SIMDOperations {
+
+    private static final Logger LOGGER = Logger.getLogger("SurvivalCore");
+    private static boolean vectorApiAvailable = false;
+
+    static {
+        try {
+            // Probe for Vector API availability
+            Class.forName("jdk.incubator.vector.FloatVector");
+            vectorApiAvailable = true;
+            LOGGER.info("SIMD Vector API detected and enabled");
+        } catch (ClassNotFoundException e) {
+            LOGGER.info("SIMD Vector API not available (add --add-modules=jdk.incubator.vector to JVM flags)");
+        }
+    }
+
+    private SIMDOperations() {}
+
+    public static boolean isAvailable() {
+        return vectorApiAvailable;
+    }
+
+    /**
+     * Batch distance-squared calculations for entity distance checks.
+     * Processes 4 entity positions at a time using SIMD when available.
+     *
+     * @param originX  reference X position
+     * @param originY  reference Y position
+     * @param originZ  reference Z position
+     * @param entityX  array of entity X positions
+     * @param entityY  array of entity Y positions
+     * @param entityZ  array of entity Z positions
+     * @param results  output array for distance-squared values
+     * @param count    number of entities to process
+     */
+    public static void batchDistanceSq(
+        double originX, double originY, double originZ,
+        double[] entityX, double[] entityY, double[] entityZ,
+        double[] results, int count
+    ) {
+        if (vectorApiAvailable) {
+            batchDistanceSqSIMD(originX, originY, originZ, entityX, entityY, entityZ, results, count);
+        } else {
+            batchDistanceSqScalar(originX, originY, originZ, entityX, entityY, entityZ, results, count);
+        }
+    }
+
+    /**
+     * Scalar fallback for batch distance calculations.
+     */
+    private static void batchDistanceSqScalar(
+        double originX, double originY, double originZ,
+        double[] entityX, double[] entityY, double[] entityZ,
+        double[] results, int count
+    ) {
+        for (int i = 0; i < count; i++) {
+            double dx = entityX[i] - originX;
+            double dy = entityY[i] - originY;
+            double dz = entityZ[i] - originZ;
+            results[i] = dx * dx + dy * dy + dz * dz;
+        }
+    }
+
+    /**
+     * SIMD-accelerated batch distance calculations.
+     * Uses direct Vector API calls for optimal performance.
+     */
+    private static void batchDistanceSqSIMD(
+        double originX, double originY, double originZ,
+        double[] entityX, double[] entityY, double[] entityZ,
+        double[] results, int count
+    ) {
+        try {
+            VectorSpecies<Double> species = DoubleVector.SPECIES_256;
+            int step = species.length(); // 4
+
+            int i = 0;
+            for (; i + step <= count; i += step) {
+                // Load entity positions and subtract origin
+                DoubleVector vx = DoubleVector.fromArray(species, entityX, i).sub(originX);
+                DoubleVector vy = DoubleVector.fromArray(species, entityY, i).sub(originY);
+                DoubleVector vz = DoubleVector.fromArray(species, entityZ, i).sub(originZ);
+
+                // Compute distance squared: dx^2 + dy^2 + dz^2
+                DoubleVector result = vx.mul(vx).add(vy.mul(vy)).add(vz.mul(vz));
+
+                // Store result
+                result.intoArray(results, i);
+            }
+
+            // Scalar tail for remaining elements
+            for (; i < count; i++) {
+                double dx = entityX[i] - originX;
+                double dy = entityY[i] - originY;
+                double dz = entityZ[i] - originZ;
+                results[i] = dx * dx + dy * dy + dz * dz;
+            }
+        } catch (Exception e) {
+            // Fallback to scalar if SIMD fails
+            LOGGER.warning("SIMD batch distance calculation failed, using scalar fallback: " + e.getMessage());
+            batchDistanceSqScalar(originX, originY, originZ, entityX, entityY, entityZ, results, count);
+        }
+    }
+
+    /**
+     * Batch color distance calculations for map rendering.
+     * Computes distances between a target color and an array of palette colors.
+     * Processes 8 colors at a time using SIMD when available.
+     *
+     * @param targetR  target red component
+     * @param targetG  target green component
+     * @param targetB  target blue component
+     * @param paletteR palette red components
+     * @param paletteG palette green components
+     * @param paletteB palette blue components
+     * @param results  output array for distance values
+     * @param count    number of palette entries
+     */
+    public static void batchColorDistance(
+        float targetR, float targetG, float targetB,
+        float[] paletteR, float[] paletteG, float[] paletteB,
+        float[] results, int count
+    ) {
+        if (vectorApiAvailable) {
+            batchColorDistanceSIMD(targetR, targetG, targetB, paletteR, paletteG, paletteB, results, count);
+        } else {
+            batchColorDistanceScalar(targetR, targetG, targetB, paletteR, paletteG, paletteB, results, count);
+        }
+    }
+
+    /**
+     * Scalar fallback for batch color distance calculations.
+     */
+    private static void batchColorDistanceScalar(
+        float targetR, float targetG, float targetB,
+        float[] paletteR, float[] paletteG, float[] paletteB,
+        float[] results, int count
+    ) {
+        for (int i = 0; i < count; i++) {
+            float dr = paletteR[i] - targetR;
+            float dg = paletteG[i] - targetG;
+            float db = paletteB[i] - targetB;
+            results[i] = dr * dr + dg * dg + db * db;
+        }
+    }
+
+    /**
+     * SIMD-accelerated batch color distance calculations.
+     * Uses direct Vector API calls for optimal performance.
+     */
+    private static void batchColorDistanceSIMD(
+        float targetR, float targetG, float targetB,
+        float[] paletteR, float[] paletteG, float[] paletteB,
+        float[] results, int count
+    ) {
+        try {
+            VectorSpecies<Float> species = FloatVector.SPECIES_256;
+            int step = species.length(); // 8
+
+            int i = 0;
+            for (; i + step <= count; i += step) {
+                // Load palette colors and subtract target
+                FloatVector vr = FloatVector.fromArray(species, paletteR, i).sub(targetR);
+                FloatVector vg = FloatVector.fromArray(species, paletteG, i).sub(targetG);
+                FloatVector vb = FloatVector.fromArray(species, paletteB, i).sub(targetB);
+
+                // Compute color distance squared: dr^2 + dg^2 + db^2
+                FloatVector result = vr.mul(vr).add(vg.mul(vg)).add(vb.mul(vb));
+
+                // Store result
+                result.intoArray(results, i);
+            }
+
+            // Scalar tail for remaining elements
+            for (; i < count; i++) {
+                float dr = paletteR[i] - targetR;
+                float dg = paletteG[i] - targetG;
+                float db = paletteB[i] - targetB;
+                results[i] = dr * dr + dg * dg + db * db;
+            }
+        } catch (Exception e) {
+            // Fallback to scalar if SIMD fails
+            LOGGER.warning("SIMD batch color distance calculation failed, using scalar fallback: " + e.getMessage());
+            batchColorDistanceScalar(targetR, targetG, targetB, paletteR, paletteG, paletteB, results, count);
+        }
+    }
+
+    /**
+     * Find the minimum value index in a float array.
+     * Used for nearest-color lookup in map rendering.
+     */
+    public static int findMinIndex(float[] values, int count) {
+        int minIdx = 0;
+        float minVal = values[0];
+        for (int i = 1; i < count; i++) {
+            if (values[i] < minVal) {
+                minVal = values[i];
+                minIdx = i;
+            }
+        }
+        return minIdx;
+    }
+}
