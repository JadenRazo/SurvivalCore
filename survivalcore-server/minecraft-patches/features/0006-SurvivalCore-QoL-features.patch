From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: JadenRazo <jadenrazo@yahoo.com>
Date: Thu, 12 Feb 2026 22:12:16 +0000
Subject: [PATCH] SurvivalCore QoL features


diff --git a/net/minecraft/server/level/ServerLevel.java b/net/minecraft/server/level/ServerLevel.java
index dda8d38ef61672cc714d9e5a475f9b0412ed5ff9..e5d77e97f57d8585d7811cc9c1bd3caa8ec16069 100644
--- a/net/minecraft/server/level/ServerLevel.java
+++ b/net/minecraft/server/level/ServerLevel.java
@@ -721,7 +721,15 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
         }
 
         int _int = this.getGameRules().getInt(GameRules.RULE_PLAYERS_SLEEPING_PERCENTAGE);
-        if (this.sleepStatus.areEnoughSleeping(_int) && this.sleepStatus.areEnoughDeepSleeping(_int, this.players)) {
+        // SurvivalCore start - Single-player sleep
+        boolean survivalcoreSleepCheck;
+        if (net.survivalcore.qol.SleepHandler.isSinglePlayerSleepEnabled()) {
+            survivalcoreSleepCheck = this.sleepStatus.amountSleeping() >= 1;
+        } else {
+            survivalcoreSleepCheck = this.sleepStatus.areEnoughSleeping(_int) && this.sleepStatus.areEnoughDeepSleeping(_int, this.players);
+        }
+        if (survivalcoreSleepCheck) {
+        // SurvivalCore end
             // Paper start - create time skip event - move up calculations
             final long newDayTime = this.levelData.getDayTime() + 24000L;
             org.bukkit.event.world.TimeSkipEvent event = new org.bukkit.event.world.TimeSkipEvent(
@@ -741,9 +749,18 @@ public class ServerLevel extends Level implements ServerEntityGetter, WorldGenLe
             }
 
             if (!event.isCancelled()) this.wakeUpAllPlayers(); // Paper - only wake up players if time skip event is not cancelled
-            if (this.getGameRules().getBoolean(GameRules.RULE_WEATHER_CYCLE) && this.isRaining()) {
+            // SurvivalCore start - Always clear weather on sleep if configured
+            if ((net.survivalcore.qol.SleepHandler.shouldClearWeather() || this.getGameRules().getBoolean(GameRules.RULE_WEATHER_CYCLE)) && this.isRaining()) {
+            // SurvivalCore end
                 this.resetWeatherCycle();
             }
+            // SurvivalCore start - Reset phantom timers on sleep
+            if (net.survivalcore.qol.SleepHandler.shouldResetPhantomTimers()) {
+                for (ServerPlayer sp : this.players) {
+                    sp.getStats().setValue(sp, net.minecraft.stats.Stats.CUSTOM.get(net.minecraft.stats.Stats.TIME_SINCE_REST), 0);
+                }
+            }
+            // SurvivalCore end
         }
 
         this.updateSkyBrightness();
diff --git a/net/minecraft/server/level/ServerPlayer.java b/net/minecraft/server/level/ServerPlayer.java
index 8f94c963f2c59668d72d162f46f7505d6a6b06a5..e0d683765806a62fd4d65b49c9244edf2e7c7b6f 100644
--- a/net/minecraft/server/level/ServerPlayer.java
+++ b/net/minecraft/server/level/ServerPlayer.java
@@ -1132,6 +1132,20 @@ public class ServerPlayer extends Player implements ca.spottedleaf.moonrise.patc
         }
 
         this.level().broadcastEntityEvent(this, (byte)3);
+        // SurvivalCore start - Player head drop on PvP death
+        if (net.survivalcore.qol.PlayerHeadDrop.isEnabled() && cause.getEntity() instanceof ServerPlayer) {
+            if (net.survivalcore.qol.PlayerHeadDrop.shouldDropHead(this.getRandom().nextDouble())) {
+                net.minecraft.world.item.ItemStack headStack = new net.minecraft.world.item.ItemStack(net.minecraft.world.item.Items.PLAYER_HEAD);
+                headStack.set(
+                    net.minecraft.core.component.DataComponents.PROFILE,
+                    new net.minecraft.world.item.component.ResolvableProfile(this.getGameProfile())
+                );
+                net.minecraft.world.entity.item.ItemEntity headEntity = new net.minecraft.world.entity.item.ItemEntity(
+                    this.level(), this.getX(), this.getY(), this.getZ(), headStack);
+                this.level().addFreshEntity(headEntity, org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.CUSTOM);
+            }
+        }
+        // SurvivalCore end
         this.awardStat(Stats.DEATHS);
         this.resetStat(Stats.CUSTOM.get(Stats.TIME_SINCE_DEATH));
         this.resetStat(Stats.CUSTOM.get(Stats.TIME_SINCE_REST));
diff --git a/net/minecraft/world/entity/LivingEntity.java b/net/minecraft/world/entity/LivingEntity.java
index 0268e02d2ef2cb3d699644a804e23a6da4521f4c..9edcabfda46edf802fe80d2d3110a64e1bf79b76 100644
--- a/net/minecraft/world/entity/LivingEntity.java
+++ b/net/minecraft/world/entity/LivingEntity.java
@@ -2039,6 +2039,15 @@ public abstract class LivingEntity extends Entity implements Attackable, Waypoin
 
     public void knockback(double strength, double x, double z, @Nullable Entity attacker, io.papermc.paper.event.entity.EntityKnockbackEvent.Cause eventCause) { // Paper - knockback events
         strength *= 1.0 - this.getAttributeValue(Attributes.KNOCKBACK_RESISTANCE);
+        // SurvivalCore start - Configurable knockback multipliers
+        if (net.survivalcore.config.SurvivalCoreConfig.get() != null) {
+            if (this instanceof net.minecraft.server.level.ServerPlayer) {
+                strength *= net.survivalcore.config.SurvivalCoreConfig.get().qolKnockbackPlayerMultiplier;
+            } else {
+                strength *= net.survivalcore.config.SurvivalCoreConfig.get().qolKnockbackMobMultiplier;
+            }
+        }
+        // SurvivalCore end
         if (true || !(strength <= 0.0)) { // CraftBukkit - Call event even when force is 0
             // this.hasImpulse = true; // CraftBukkit - Move down
             Vec3 deltaMovement = this.getDeltaMovement();
diff --git a/net/minecraft/world/level/levelgen/PhantomSpawner.java b/net/minecraft/world/level/levelgen/PhantomSpawner.java
index b3cfab9c82fe12694f5d2f56bd922828e51df680..a809c8d3e407b4074be64adf45de2f41b83c922d 100644
--- a/net/minecraft/world/level/levelgen/PhantomSpawner.java
+++ b/net/minecraft/world/level/levelgen/PhantomSpawner.java
@@ -41,12 +41,23 @@ public class PhantomSpawner implements CustomSpawner {
                     if (level.getSkyDarken() >= 5 || !level.dimensionType().hasSkyLight()) {
                         for (ServerPlayer serverPlayer : level.players()) {
                             if (!serverPlayer.isSpectator() && (!level.paperConfig().entities.behavior.phantomsDoNotSpawnOnCreativePlayers || !serverPlayer.isCreative())) { // Paper - Add phantom creative and insomniac controls
+                                // SurvivalCore start - Phantom spawning control
+                                if (!net.survivalcore.qol.PhantomControl.isPhantomsEnabled()) {
+                                    continue;
+                                }
+                                // SurvivalCore end
                                 BlockPos blockPos = serverPlayer.blockPosition();
                                 if (!level.dimensionType().hasSkyLight() || blockPos.getY() >= level.getSeaLevel() && level.canSeeSky(blockPos)) {
                                     DifficultyInstance currentDifficultyAt = level.getCurrentDifficultyAt(blockPos);
                                     if (currentDifficultyAt.isHarderThan(randomSource.nextFloat() * 3.0F)) {
                                         ServerStatsCounter stats = serverPlayer.getStats();
                                         int i = Mth.clamp(stats.getValue(Stats.CUSTOM.get(Stats.TIME_SINCE_REST)), 1, Integer.MAX_VALUE);
+                                        // SurvivalCore start - Configurable phantom insomnia threshold
+                                        if (!net.survivalcore.qol.PhantomControl.shouldSpawnPhantom(
+                                                i, level.canSeeSky(blockPos), serverPlayer.getY(), level.getSeaLevel())) {
+                                            continue;
+                                        }
+                                        // SurvivalCore end
                                         int i1 = 24000;
                                         if (randomSource.nextInt(i) >= 72000) {
                                             BlockPos blockPos1 = blockPos.above(20 + randomSource.nextInt(15))
